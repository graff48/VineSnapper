<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Donkey Kong Jr.</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  overflow: hidden;
}
#gameContainer {
  position: relative;
}
canvas {
  display: block;
  image-rendering: pixelated;
  border: 2px solid #333;
}
#overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  background: rgba(0,0,0,0.85);
  color: #fff;
  z-index: 10;
}
#overlay.hidden { display: none; }
#overlay h1 { font-size: 28px; color: #f44; margin-bottom: 8px; text-transform: uppercase; }
#overlay h2 { font-size: 18px; color: #ff0; margin-bottom: 20px; }
#overlay .instructions {
  font-size: 13px;
  color: #aaa;
  text-align: center;
  line-height: 1.8;
  margin-bottom: 20px;
}
#overlay .start-btn {
  font-size: 18px;
  color: #0f0;
  cursor: pointer;
  animation: blink 1s infinite;
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="game" width="512" height="480"></canvas>
  <div id="overlay">
    <h1>Donkey Kong Jr.</h1>
    <h2>Save Papa!</h2>
    <div class="instructions">
      Arrow Keys / WASD - Move &amp; Climb<br>
      Space - Jump | Z/X - Fire<br>
      Climb vines to push keys into locks!<br>
      Avoid Snapjaws &amp; Beetles!<br>
      Grab the flamethrower to roast Beetles!<br>
      Collect fruit for bonus points!
    </div>
    <div class="start-btn" id="startBtn">PRESS SPACE TO START</div>
  </div>
</div>

<script>
// ============================================================
// DONKEY KONG JR. - Browser Clone
// ============================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const W = canvas.width;
const H = canvas.height;

// ---- CONSTANTS ----
const GRAVITY = 0.45;
const PLAYER_SPEED = 2.2;
const JUMP_FORCE = -6.5;
const CLIMB_SPEED = 1.8;
const CLIMB_SPEED_FAST = 2.8;
const CLIMB_SPEED_DOWN = 2.5;
const TILE = 16;
const ENEMY_SPEED = 1.0;
const KEY_RISE_SPEED = 0.8;
const ROUND_TIME = 120 * 60; // 2 minutes in frames (60fps)

// ---- GAME STATE ----
let gameState = 'title'; // title, playing, dying, gameover, winning, levelComplete
let score = 0;
let highScore = parseInt(localStorage.getItem('dkjr_high') || '0');
let lives = 3;
let level = 1;
let deathTimer = 0;
let winTimer = 0;
let levelCompleteTimer = 0;
let frameCount = 0;
let roundTimer = ROUND_TIME;

// ---- INPUT ----
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') {
    e.preventDefault();
    if (gameState === 'title') startGame();
    else if (gameState === 'gameover') { gameState = 'title'; showOverlay(); }
  }
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

function isLeft() { return keys['ArrowLeft'] || keys['KeyA']; }
function isRight() { return keys['ArrowRight'] || keys['KeyD']; }
function isUp() { return keys['ArrowUp'] || keys['KeyW']; }
function isDown() { return keys['ArrowDown'] || keys['KeyS']; }
function isJump() { return keys['Space']; }
function isFire() { return keys['KeyZ'] || keys['KeyX']; }

// ---- COLORS ----
const LEVEL_PALETTES = [
  { // Level 1: Classic jungle - warm greens and browns
    bg: '#001a00',
    platform: '#c84c0c',
    platformTop: '#e87040',
    vine: '#0a0',
    vineChain: '#888',
    player: '#f80',
    playerShirt: '#c00',
    dk: '#a52',
    cage: '#aaa',
    snapjawRed: '#f00',
    snapjawBlue: '#22f',
    fruit: '#ff0',
    key: '#ff0',
    lock: '#888',
    text: '#fff',
    scoreText: '#0ff',
    beetle: '#4a2',
    beetleShell: '#6c3',
    flamethrower: '#f60',
    flame1: '#f80',
    flame2: '#ff0',
    flame3: '#f44',
  },
  { // Level 2: Twilight cavern - purples and blues
    bg: '#0a0014',
    platform: '#5a2d82',
    platformTop: '#8040c0',
    vine: '#2dd',
    vineChain: '#99a',
    player: '#f90',
    playerShirt: '#d22',
    dk: '#a63',
    cage: '#bba',
    snapjawRed: '#f44',
    snapjawBlue: '#48f',
    fruit: '#0ff',
    key: '#0ff',
    lock: '#99a',
    text: '#eef',
    scoreText: '#f8f',
    beetle: '#5a4080',
    beetleShell: '#8060b0',
    flamethrower: '#f80',
    flame1: '#f60',
    flame2: '#ff0',
    flame3: '#f88',
  },
  { // Level 3: Frozen sky - icy blues and white
    bg: '#000a1a',
    platform: '#1a5a8a',
    platformTop: '#40a0e0',
    vine: '#e0e0ff',
    vineChain: '#80c0f0',
    player: '#ff0',
    playerShirt: '#f60',
    dk: '#b63',
    cage: '#cde',
    snapjawRed: '#f44',
    snapjawBlue: '#0ef',
    fruit: '#f0f',
    key: '#f0f',
    lock: '#6aa',
    text: '#eef',
    scoreText: '#4df',
    beetle: '#2a6a4a',
    beetleShell: '#40a070',
    flamethrower: '#fa0',
    flame1: '#f80',
    flame2: '#ff4',
    flame3: '#f66',
  },
];
let COLORS = { ...LEVEL_PALETTES[0] };

function applyLevelPalette(lvl) {
  const idx = ((lvl - 1) % 3);
  Object.assign(COLORS, LEVEL_PALETTES[idx]);
}

// ---- LEVEL DATA ----
function buildLevel(lvl) {
  const platforms = [];
  const vines = [];
  const fruits = [];
  const enemySpawns = [];
  const lockPositions = [];
  const keyPositions = [];
  const beetleSpawns = [];
  let flamethrower = null;

  // Ground platform
  platforms.push({ x: 0, y: H - 32, w: W, h: 16 });

  if (lvl === 1 || (lvl % 3) === 1) {
    // Level 1 layout - classic vine climbing
    // Platforms (ascending, staggered)
    platforms.push({ x: 0, y: H - 100, w: 180, h: 10 });
    platforms.push({ x: 200, y: H - 100, w: 160, h: 10 });
    platforms.push({ x: 400, y: H - 100, w: 112, h: 10 });

    platforms.push({ x: 40, y: H - 170, w: 200, h: 10 });
    platforms.push({ x: 300, y: H - 170, w: 180, h: 10 });

    platforms.push({ x: 0, y: H - 240, w: 160, h: 10 });
    platforms.push({ x: 220, y: H - 240, w: 150, h: 10 });
    platforms.push({ x: 410, y: H - 240, w: 102, h: 10 });

    platforms.push({ x: 60, y: H - 310, w: 180, h: 10 });
    platforms.push({ x: 300, y: H - 310, w: 170, h: 10 });

    // Top platform (DK cage area)
    platforms.push({ x: 100, y: H - 380, w: 320, h: 10 });

    // Vines connecting platforms
    // From ground to first tier
    vines.push({ x: 100, y1: H - 100, y2: H - 32, isChain: false });
    vines.push({ x: 140, y1: H - 100, y2: H - 32, isChain: false });
    vines.push({ x: 300, y1: H - 100, y2: H - 32, isChain: true });
    vines.push({ x: 450, y1: H - 100, y2: H - 32, isChain: false });

    // First to second tier
    vines.push({ x: 80, y1: H - 170, y2: H - 100, isChain: true });
    vines.push({ x: 200, y1: H - 170, y2: H - 100, isChain: false });
    vines.push({ x: 360, y1: H - 170, y2: H - 100, isChain: false });
    vines.push({ x: 420, y1: H - 170, y2: H - 100, isChain: true });

    // Second to third tier
    vines.push({ x: 60, y1: H - 240, y2: H - 170, isChain: false });
    vines.push({ x: 150, y1: H - 240, y2: H - 170, isChain: false });
    vines.push({ x: 270, y1: H - 240, y2: H - 170, isChain: true });
    vines.push({ x: 440, y1: H - 240, y2: H - 170, isChain: false });

    // Third to fourth tier
    vines.push({ x: 120, y1: H - 310, y2: H - 240, isChain: true });
    vines.push({ x: 240, y1: H - 310, y2: H - 240, isChain: false });
    vines.push({ x: 350, y1: H - 310, y2: H - 240, isChain: false });
    vines.push({ x: 430, y1: H - 310, y2: H - 240, isChain: true });

    // Fourth to top
    vines.push({ x: 180, y1: H - 380, y2: H - 310, isChain: false });
    vines.push({ x: 260, y1: H - 380, y2: H - 310, isChain: true });
    vines.push({ x: 340, y1: H - 380, y2: H - 310, isChain: false });
    vines.push({ x: 400, y1: H - 380, y2: H - 310, isChain: false });

    // Fruits
    fruits.push({ x: 120, y: H - 140, type: 0, collected: false });
    fruits.push({ x: 380, y: H - 140, type: 1, collected: false });
    fruits.push({ x: 200, y: H - 210, type: 2, collected: false });
    fruits.push({ x: 440, y: H - 280, type: 0, collected: false });
    fruits.push({ x: 100, y: H - 280, type: 1, collected: false });
    fruits.push({ x: 300, y: H - 350, type: 2, collected: false });

    // Enemy spawns on vines
    enemySpawns.push({ vineIdx: 2, y: H - 60, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 7, y: H - 130, dir: 1, type: 'blue' });
    enemySpawns.push({ vineIdx: 10, y: H - 200, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 13, y: H - 270, dir: 1, type: 'blue' });
    enemySpawns.push({ vineIdx: 15, y: H - 340, dir: -1, type: 'red' });

    // Keys & locks
    keyPositions.push({ x: 180, y: H - 395, vineIdx: 17, locked: true, rising: false, atLock: false });
    keyPositions.push({ x: 340, y: H - 395, vineIdx: 19, locked: true, rising: false, atLock: false });

    lockPositions.push({ x: 180, y: H - 430 });
    lockPositions.push({ x: 340, y: H - 430 });

    // Beetles - patrol on platforms (platformIdx is index into platforms array)
    beetleSpawns.push({ x: 30, y: H - 110, platformIdx: 1, dir: 1, speed: 0.8 });
    beetleSpawns.push({ x: 320, y: H - 180, platformIdx: 5, dir: -1, speed: 1.0 });
    beetleSpawns.push({ x: 250, y: H - 250, platformIdx: 7, dir: 1, speed: 0.9 });

    // Flamethrower pickup on second tier platform
    flamethrower = { x: 160, y: H - 180, collected: false };

  } else if ((lvl % 3) === 2) {
    // Level 2 layout - more chains, more enemies
    platforms.push({ x: 0, y: H - 90, w: 140, h: 10 });
    platforms.push({ x: 180, y: H - 90, w: 140, h: 10 });
    platforms.push({ x: 370, y: H - 90, w: 142, h: 10 });

    platforms.push({ x: 30, y: H - 160, w: 200, h: 10 });
    platforms.push({ x: 280, y: H - 160, w: 200, h: 10 });

    platforms.push({ x: 0, y: H - 230, w: 170, h: 10 });
    platforms.push({ x: 190, y: H - 230, w: 140, h: 10 });
    platforms.push({ x: 370, y: H - 230, w: 142, h: 10 });

    platforms.push({ x: 50, y: H - 300, w: 420, h: 10 });

    platforms.push({ x: 120, y: H - 370, w: 280, h: 10 });

    // Vines
    vines.push({ x: 70, y1: H - 90, y2: H - 32, isChain: true });
    vines.push({ x: 250, y1: H - 90, y2: H - 32, isChain: false });
    vines.push({ x: 310, y1: H - 90, y2: H - 32, isChain: true });
    vines.push({ x: 440, y1: H - 90, y2: H - 32, isChain: false });

    vines.push({ x: 100, y1: H - 160, y2: H - 90, isChain: false });
    vines.push({ x: 180, y1: H - 160, y2: H - 90, isChain: true });
    vines.push({ x: 340, y1: H - 160, y2: H - 90, isChain: false });
    vines.push({ x: 450, y1: H - 160, y2: H - 90, isChain: true });

    vines.push({ x: 60, y1: H - 230, y2: H - 160, isChain: true });
    vines.push({ x: 230, y1: H - 230, y2: H - 160, isChain: false });
    vines.push({ x: 300, y1: H - 230, y2: H - 160, isChain: false });
    vines.push({ x: 430, y1: H - 230, y2: H - 160, isChain: true });

    vines.push({ x: 130, y1: H - 300, y2: H - 230, isChain: false });
    vines.push({ x: 260, y1: H - 300, y2: H - 230, isChain: true });
    vines.push({ x: 380, y1: H - 300, y2: H - 230, isChain: false });

    vines.push({ x: 200, y1: H - 370, y2: H - 300, isChain: true });
    vines.push({ x: 300, y1: H - 370, y2: H - 300, isChain: false });
    vines.push({ x: 370, y1: H - 370, y2: H - 300, isChain: false });

    fruits.push({ x: 70, y: H - 130, type: 0, collected: false });
    fruits.push({ x: 440, y: H - 130, type: 1, collected: false });
    fruits.push({ x: 230, y: H - 200, type: 2, collected: false });
    fruits.push({ x: 130, y: H - 270, type: 0, collected: false });
    fruits.push({ x: 380, y: H - 270, type: 1, collected: false });
    fruits.push({ x: 260, y: H - 340, type: 2, collected: false });

    enemySpawns.push({ vineIdx: 0, y: H - 55, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 3, y: H - 55, dir: 1, type: 'red' });
    enemySpawns.push({ vineIdx: 5, y: H - 120, dir: -1, type: 'blue' });
    enemySpawns.push({ vineIdx: 7, y: H - 120, dir: 1, type: 'blue' });
    enemySpawns.push({ vineIdx: 9, y: H - 190, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 11, y: H - 190, dir: 1, type: 'red' });
    enemySpawns.push({ vineIdx: 13, y: H - 260, dir: -1, type: 'blue' });

    keyPositions.push({ x: 200, y: H - 385, vineIdx: 15, locked: true, rising: false, atLock: false });
    keyPositions.push({ x: 300, y: H - 385, vineIdx: 16, locked: true, rising: false, atLock: false });
    keyPositions.push({ x: 370, y: H - 385, vineIdx: 17, locked: true, rising: false, atLock: false });

    lockPositions.push({ x: 200, y: H - 425 });
    lockPositions.push({ x: 300, y: H - 425 });
    lockPositions.push({ x: 370, y: H - 425 });

    // Beetles
    beetleSpawns.push({ x: 200, y: H - 100, platformIdx: 2, dir: 1, speed: 0.9 });
    beetleSpawns.push({ x: 100, y: H - 170, platformIdx: 4, dir: -1, speed: 1.0 });
    beetleSpawns.push({ x: 50, y: H - 240, platformIdx: 6, dir: 1, speed: 1.1 });
    beetleSpawns.push({ x: 400, y: H - 240, platformIdx: 8, dir: -1, speed: 0.9 });

    // Flamethrower pickup
    flamethrower = { x: 350, y: H - 170, collected: false };

  } else {
    // Level 3 layout - hardest
    platforms.push({ x: 20, y: H - 80, w: 200, h: 10 });
    platforms.push({ x: 290, y: H - 80, w: 200, h: 10 });

    platforms.push({ x: 0, y: H - 145, w: 150, h: 10 });
    platforms.push({ x: 180, y: H - 145, w: 160, h: 10 });
    platforms.push({ x: 370, y: H - 145, w: 142, h: 10 });

    platforms.push({ x: 40, y: H - 210, w: 180, h: 10 });
    platforms.push({ x: 260, y: H - 210, w: 210, h: 10 });

    platforms.push({ x: 0, y: H - 275, w: 160, h: 10 });
    platforms.push({ x: 200, y: H - 275, w: 120, h: 10 });
    platforms.push({ x: 360, y: H - 275, w: 152, h: 10 });

    platforms.push({ x: 80, y: H - 340, w: 360, h: 10 });

    platforms.push({ x: 140, y: H - 400, w: 240, h: 10 });

    vines.push({ x: 80, y1: H - 80, y2: H - 32, isChain: false });
    vines.push({ x: 180, y1: H - 80, y2: H - 32, isChain: true });
    vines.push({ x: 350, y1: H - 80, y2: H - 32, isChain: false });
    vines.push({ x: 450, y1: H - 80, y2: H - 32, isChain: true });

    vines.push({ x: 60, y1: H - 145, y2: H - 80, isChain: true });
    vines.push({ x: 140, y1: H - 145, y2: H - 80, isChain: false });
    vines.push({ x: 250, y1: H - 145, y2: H - 80, isChain: false });
    vines.push({ x: 330, y1: H - 145, y2: H - 80, isChain: true });
    vines.push({ x: 430, y1: H - 145, y2: H - 80, isChain: false });

    vines.push({ x: 90, y1: H - 210, y2: H - 145, isChain: false });
    vines.push({ x: 200, y1: H - 210, y2: H - 145, isChain: true });
    vines.push({ x: 310, y1: H - 210, y2: H - 145, isChain: false });
    vines.push({ x: 420, y1: H - 210, y2: H - 145, isChain: true });

    vines.push({ x: 50, y1: H - 275, y2: H - 210, isChain: true });
    vines.push({ x: 160, y1: H - 275, y2: H - 210, isChain: false });
    vines.push({ x: 240, y1: H - 275, y2: H - 210, isChain: false });
    vines.push({ x: 400, y1: H - 275, y2: H - 210, isChain: true });

    vines.push({ x: 120, y1: H - 340, y2: H - 275, isChain: false });
    vines.push({ x: 260, y1: H - 340, y2: H - 275, isChain: true });
    vines.push({ x: 380, y1: H - 340, y2: H - 275, isChain: false });

    vines.push({ x: 200, y1: H - 400, y2: H - 340, isChain: true });
    vines.push({ x: 280, y1: H - 400, y2: H - 340, isChain: false });
    vines.push({ x: 350, y1: H - 400, y2: H - 340, isChain: false });

    fruits.push({ x: 180, y: H - 55, type: 0, collected: false });
    fruits.push({ x: 350, y: H - 55, type: 1, collected: false });
    fruits.push({ x: 60, y: H - 115, type: 2, collected: false });
    fruits.push({ x: 430, y: H - 115, type: 0, collected: false });
    fruits.push({ x: 160, y: H - 180, type: 1, collected: false });
    fruits.push({ x: 400, y: H - 245, type: 2, collected: false });
    fruits.push({ x: 120, y: H - 310, type: 0, collected: false });
    fruits.push({ x: 380, y: H - 310, type: 1, collected: false });

    enemySpawns.push({ vineIdx: 1, y: H - 50, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 3, y: H - 50, dir: 1, type: 'blue' });
    enemySpawns.push({ vineIdx: 4, y: H - 110, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 8, y: H - 110, dir: 1, type: 'red' });
    enemySpawns.push({ vineIdx: 10, y: H - 175, dir: -1, type: 'blue' });
    enemySpawns.push({ vineIdx: 12, y: H - 175, dir: 1, type: 'blue' });
    enemySpawns.push({ vineIdx: 14, y: H - 240, dir: -1, type: 'red' });
    enemySpawns.push({ vineIdx: 16, y: H - 240, dir: 1, type: 'red' });

    keyPositions.push({ x: 200, y: H - 415, vineIdx: 20, locked: true, rising: false, atLock: false });
    keyPositions.push({ x: 280, y: H - 415, vineIdx: 21, locked: true, rising: false, atLock: false });
    keyPositions.push({ x: 350, y: H - 415, vineIdx: 22, locked: true, rising: false, atLock: false });

    lockPositions.push({ x: 200, y: H - 450 });
    lockPositions.push({ x: 280, y: H - 450 });
    lockPositions.push({ x: 350, y: H - 450 });

    // Beetles
    beetleSpawns.push({ x: 60, y: H - 90, platformIdx: 1, dir: 1, speed: 1.0 });
    beetleSpawns.push({ x: 380, y: H - 90, platformIdx: 2, dir: -1, speed: 0.9 });
    beetleSpawns.push({ x: 200, y: H - 155, platformIdx: 4, dir: 1, speed: 1.1 });
    beetleSpawns.push({ x: 80, y: H - 220, platformIdx: 6, dir: -1, speed: 1.0 });
    beetleSpawns.push({ x: 300, y: H - 285, platformIdx: 9, dir: 1, speed: 1.2 });

    // Flamethrower pickup
    flamethrower = { x: 300, y: H - 220, collected: false };
  }

  return { platforms, vines, fruits, enemySpawns, lockPositions, keyPositions, beetleSpawns, flamethrower };
}

// ---- PLAYER ----
let player = {};
function resetPlayer() {
  player = {
    x: 50, y: H - 48,
    w: 16, h: 20,
    vx: 0, vy: 0,
    onGround: false,
    climbing: false,
    climbVine: -1,
    nearbyVines: [],
    facing: 1,
    animFrame: 0,
    animTimer: 0,
    jumpPressed: false,
    invincible: 0,
    hasFlamethrower: false,
    flameActive: false,
    flameTimer: 0,
  };
  roundTimer = ROUND_TIME;
}

// ---- LEVEL STATE ----
let levelData = {};
let enemies = [];
let beetles = [];
let particles = [];
let scorePopups = [];
let enemySpawnTimer = 0;

function initLevel() {
  applyLevelPalette(level);
  levelData = buildLevel(level);
  enemies = [];
  particles = [];
  scorePopups = [];
  enemySpawnTimer = 0;
  roundTimer = ROUND_TIME;
  resetPlayer();

  // Reset keys
  levelData.keyPositions.forEach(k => {
    k.locked = true;
    k.rising = false;
    k.atLock = false;
  });

  // Reset fruits
  levelData.fruits.forEach(f => f.collected = false);

  // Reset flamethrower
  if (levelData.flamethrower) levelData.flamethrower.collected = false;

  // Spawn beetles from level data
  beetles = [];
  for (const bs of levelData.beetleSpawns) {
    const plat = levelData.platforms[bs.platformIdx];
    if (!plat) continue;
    beetles.push({
      x: bs.x,
      y: plat.y - 14,
      w: 16, h: 14,
      dir: bs.dir,
      speed: bs.speed + (level - 1) * 0.1,
      platformIdx: bs.platformIdx,
      animFrame: 0,
      alive: true,
    });
  }
}

// ---- AUDIO (simple synth) ----
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
  try {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const t = audioCtx.currentTime;

    switch(type) {
      case 'jump':
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, t);
        osc.frequency.linearRampToValueAtTime(600, t + 0.15);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.15);
        osc.start(t); osc.stop(t + 0.15);
        break;
      case 'climb':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300 + (frameCount % 2) * 100, t);
        gain.gain.setValueAtTime(0.05, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.05);
        osc.start(t); osc.stop(t + 0.05);
        break;
      case 'fruit':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, t);
        osc.frequency.linearRampToValueAtTime(1200, t + 0.1);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.15);
        osc.start(t); osc.stop(t + 0.15);
        break;
      case 'key':
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.linearRampToValueAtTime(800, t + 0.2);
        osc.frequency.linearRampToValueAtTime(1000, t + 0.4);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.4);
        osc.start(t); osc.stop(t + 0.4);
        break;
      case 'die':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, t);
        osc.frequency.linearRampToValueAtTime(100, t + 0.5);
        gain.gain.setValueAtTime(0.12, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.5);
        osc.start(t); osc.stop(t + 0.5);
        break;
      case 'win':
        osc.type = 'square';
        [400,500,600,800].forEach((f, i) => {
          osc.frequency.setValueAtTime(f, t + i * 0.15);
        });
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.6);
        osc.start(t); osc.stop(t + 0.6);
        break;
      case 'flame':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(120, t);
        osc.frequency.linearRampToValueAtTime(80, t + 0.3);
        gain.gain.setValueAtTime(0.12, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(t); osc.stop(t + 0.3);
        // Add noise burst for crackling
        {
          const bufSize = audioCtx.sampleRate * 0.15;
          const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
          const data = buf.getChannelData(0);
          for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.3));
          const src = audioCtx.createBufferSource();
          src.buffer = buf;
          const g2 = audioCtx.createGain();
          g2.gain.setValueAtTime(0.08, t);
          g2.gain.linearRampToValueAtTime(0, t + 0.15);
          src.connect(g2);
          g2.connect(audioCtx.destination);
          src.start(t);
        }
        return; // Already connected manually
      case 'pickup':
        osc.type = 'square';
        osc.frequency.setValueAtTime(500, t);
        osc.frequency.linearRampToValueAtTime(900, t + 0.08);
        osc.frequency.linearRampToValueAtTime(1200, t + 0.15);
        gain.gain.setValueAtTime(0.1, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.2);
        osc.start(t); osc.stop(t + 0.2);
        break;
    }
  } catch(e) {}
}

// ---- MUSIC ----
let musicPlaying = false;
let musicInterval = null;

function getLevelMusic(lvl) {
  const mod = ((lvl - 1) % 3) + 1;
  if (mod === 1) {
    // Level 1: Bright, bouncy jungle romp (C major pentatonic, 170 bpm)
    return {
      bpm: 170,
      bassWave: 'triangle',
      melodyWave: 'square',
      bass: [
        262, 262, 0, 330, 262, 0, 392, 392,
        330, 330, 0, 262, 392, 0, 330, 0,
        294, 294, 0, 392, 330, 0, 262, 262,
        392, 0, 330, 294, 262, 330, 392, 0,
      ],
      melody: [
        784, 0, 880, 784, 0, 659, 784, 880,
        988, 0, 880, 0, 784, 659, 784, 0,
        880, 988, 0, 1047, 988, 0, 880, 784,
        659, 0, 784, 880, 988, 0, 1047, 0,
      ],
      arp: [
        523, 659, 784, 659, 523, 659, 784, 988,
        523, 659, 784, 659, 523, 784, 659, 523,
        587, 698, 880, 698, 587, 698, 880, 698,
        523, 659, 784, 988, 784, 659, 523, 0,
      ],
      kick: [
        1, 0, 0, 1, 1, 0, 1, 0,
        1, 0, 0, 1, 0, 1, 1, 0,
        1, 0, 1, 0, 1, 0, 0, 1,
        1, 0, 0, 1, 1, 0, 1, 0,
      ],
      hihat: [
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
      ],
      snare: [
        0, 0, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 0, 1,
        0, 0, 0, 0, 1, 0, 0, 0,
        0, 0, 0, 0, 1, 0, 1, 0,
      ],
    };
  } else if (mod === 2) {
    // Level 2: Driving, urgent vine chase (D minor, 185 bpm)
    return {
      bpm: 185,
      bassWave: 'sawtooth',
      melodyWave: 'square',
      bass: [
        147, 147, 175, 0, 196, 196, 0, 220,
        175, 0, 147, 147, 220, 0, 196, 175,
        165, 165, 0, 196, 220, 0, 262, 220,
        196, 0, 175, 165, 147, 147, 175, 0,
      ],
      melody: [
        587, 698, 0, 784, 880, 0, 784, 698,
        587, 0, 698, 784, 0, 880, 784, 0,
        698, 784, 880, 0, 1047, 880, 0, 784,
        698, 587, 0, 698, 784, 0, 587, 0,
      ],
      arp: [
        294, 349, 440, 349, 294, 440, 349, 294,
        349, 440, 523, 440, 349, 440, 349, 294,
        330, 392, 494, 392, 330, 494, 392, 330,
        294, 349, 440, 523, 440, 349, 294, 0,
      ],
      kick: [
        1, 0, 1, 0, 1, 0, 1, 1,
        0, 1, 0, 1, 1, 0, 1, 0,
        1, 0, 1, 1, 0, 1, 0, 1,
        0, 1, 1, 0, 1, 0, 1, 1,
      ],
      hihat: [
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
      ],
      snare: [
        0, 0, 0, 1, 0, 0, 1, 0,
        0, 0, 1, 0, 0, 1, 0, 0,
        0, 0, 0, 1, 0, 0, 1, 0,
        0, 1, 0, 0, 1, 0, 0, 1,
      ],
    };
  } else {
    // Level 3: Frantic, high-energy finale (E minor, 200 bpm)
    return {
      bpm: 200,
      bassWave: 'square',
      melodyWave: 'sawtooth',
      bass: [
        165, 0, 196, 165, 220, 0, 247, 220,
        196, 0, 165, 196, 0, 220, 247, 0,
        262, 247, 0, 220, 196, 0, 165, 196,
        220, 247, 262, 0, 247, 220, 196, 165,
      ],
      melody: [
        659, 784, 988, 0, 784, 659, 0, 784,
        988, 1175, 0, 988, 784, 0, 988, 1175,
        1319, 0, 1175, 988, 0, 784, 988, 0,
        1175, 988, 784, 659, 784, 988, 0, 659,
      ],
      arp: [
        330, 392, 494, 659, 494, 392, 330, 494,
        392, 494, 659, 784, 659, 494, 392, 330,
        370, 440, 554, 740, 554, 440, 370, 554,
        330, 392, 494, 659, 784, 659, 494, 330,
      ],
      kick: [
        1, 0, 1, 1, 0, 1, 0, 1,
        1, 0, 1, 0, 1, 1, 0, 1,
        0, 1, 1, 0, 1, 0, 1, 1,
        1, 0, 1, 0, 1, 1, 0, 1,
      ],
      hihat: [
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
      ],
      snare: [
        0, 0, 1, 0, 0, 1, 0, 1,
        0, 0, 1, 0, 1, 0, 0, 1,
        0, 1, 0, 0, 1, 0, 1, 0,
        0, 1, 0, 1, 0, 0, 1, 0,
      ],
    };
  }
}

function startMusic() {
  if (musicPlaying) return;
  ensureAudio();
  musicPlaying = true;

  const m = getLevelMusic(level);
  const beatLen = 60 / m.bpm;
  const len = m.bass.length;
  let beatIndex = 0;

  musicInterval = setInterval(() => {
    if (!musicPlaying || !audioCtx) return;
    const t = audioCtx.currentTime;
    const idx = beatIndex % len;

    // Bass
    if (m.bass[idx] > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = m.bassWave;
      osc.frequency.setValueAtTime(m.bass[idx], t);
      gain.gain.setValueAtTime(0.08, t);
      gain.gain.linearRampToValueAtTime(0, t + beatLen * 0.7);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + beatLen * 0.7);
    }

    // Melody
    if (m.melody[idx] > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = m.melodyWave;
      osc.frequency.setValueAtTime(m.melody[idx], t);
      gain.gain.setValueAtTime(0.045, t);
      gain.gain.linearRampToValueAtTime(0, t + beatLen * 0.5);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + beatLen * 0.5);
    }

    // Arpeggio (bouncy chiptune layer)
    if (m.arp[idx] > 0) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(m.arp[idx], t);
      gain.gain.setValueAtTime(0.03, t);
      gain.gain.linearRampToValueAtTime(0, t + beatLen * 0.35);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + beatLen * 0.35);
    }

    // Kick drum
    if (m.kick[idx]) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(150, t);
      osc.frequency.exponentialRampToValueAtTime(40, t + 0.08);
      gain.gain.setValueAtTime(0.18, t);
      gain.gain.linearRampToValueAtTime(0, t + 0.1);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(t);
      osc.stop(t + 0.1);
    }

    // Snare
    if (m.snare[idx]) {
      const bufSize = audioCtx.sampleRate * 0.08;
      const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.15));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.setValueAtTime(1200, t);
      filter.Q.setValueAtTime(0.8, t);
      gain.gain.setValueAtTime(0.1, t);
      gain.gain.linearRampToValueAtTime(0, t + 0.08);
      src.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      src.start(t);
    }

    // Hi-hat
    if (m.hihat[idx]) {
      const bufSize = audioCtx.sampleRate * 0.025;
      const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.08));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.setValueAtTime(7000, t);
      gain.gain.setValueAtTime(0.05, t);
      gain.gain.linearRampToValueAtTime(0, t + 0.025);
      src.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);
      src.start(t);
    }

    beatIndex++;
  }, beatLen * 1000);
}

function stopMusic() {
  musicPlaying = false;
  if (musicInterval) {
    clearInterval(musicInterval);
    musicInterval = null;
  }
}

// ---- GAME FUNCTIONS ----
function showOverlay() {
  overlay.classList.remove('hidden');
  const btn = document.getElementById('startBtn');
  if (gameState === 'gameover') {
    document.querySelector('#overlay h1').textContent = 'GAME OVER';
    document.querySelector('#overlay h2').textContent = `Score: ${score}`;
    btn.textContent = 'PRESS SPACE TO CONTINUE';
  } else {
    document.querySelector('#overlay h1').textContent = 'VINE SNAPPER';
    document.querySelector('#overlay h2').textContent = 'Save Papa!';
    btn.textContent = 'PRESS SPACE TO START';
  }
}

function startGame() {
  overlay.classList.add('hidden');
  gameState = 'playing';
  score = 0;
  lives = 3;
  level = 1;
  initLevel();
  startMusic();
}

function playerDie() {
  if (player.invincible > 0) return;
  gameState = 'dying';
  deathTimer = 90;
  lives--;
  stopMusic();
  playSound('die');
  // Death particles
  for (let i = 0; i < 15; i++) {
    particles.push({
      x: player.x + player.w/2,
      y: player.y + player.h/2,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5 - 2,
      life: 40 + Math.random() * 20,
      color: Math.random() > 0.5 ? COLORS.player : COLORS.playerShirt,
    });
  }
}

function addScorePopup(x, y, pts) {
  scorePopups.push({ x, y, pts, life: 60 });
  score += pts;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('dkjr_high', highScore.toString());
  }
}

// ---- COLLISION ----
function rectOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

function isOnPlatform(entity) {
  for (const p of levelData.platforms) {
    if (entity.x + entity.w > p.x && entity.x < p.x + p.w) {
      if (entity.y + entity.h >= p.y && entity.y + entity.h <= p.y + 8 && entity.vy >= 0) {
        return p;
      }
    }
  }
  return null;
}

function getNearbyVines(entity) {
  const result = [];
  for (let i = 0; i < levelData.vines.length; i++) {
    const v = levelData.vines[i];
    const cx = entity.x + entity.w / 2;
    if (Math.abs(cx - v.x) < 14 && entity.y + entity.h > v.y1 && entity.y < v.y2) {
      result.push(i);
    }
  }
  return result;
}

// ---- UPDATE ----
function update() {
  frameCount++;

  if (gameState === 'dying') {
    deathTimer--;
    updateParticles();
    if (deathTimer <= 0) {
      if (lives <= 0) {
        gameState = 'gameover';
        showOverlay();
      } else {
        gameState = 'playing';
        resetPlayer();
        startMusic();
      }
    }
    return;
  }

  if (gameState === 'levelComplete') {
    levelCompleteTimer--;
    updateParticles();
    if (levelCompleteTimer <= 0) {
      level++;
      initLevel();
      gameState = 'playing';
      startMusic();
    }
    return;
  }

  if (gameState === 'winning') {
    winTimer--;
    updateParticles();
    if (winTimer <= 0) {
      gameState = 'levelComplete';
      levelCompleteTimer = 90;
      addScorePopup(W/2, H/2, 1000 + level * 500);
    }
    return;
  }

  if (gameState !== 'playing') return;

  // Round timer
  roundTimer--;
  if (roundTimer <= 0) {
    roundTimer = 0;
    playerDie();
    return;
  }

  // Player invincibility
  if (player.invincible > 0) player.invincible--;

  // Animation
  player.animTimer++;
  if (player.animTimer > 8) {
    player.animTimer = 0;
    player.animFrame = (player.animFrame + 1) % 4;
  }

  // Find nearby vines
  player.nearbyVines = getNearbyVines(player);

  if (player.climbing) {
    // CLIMBING LOGIC
    let climbSpeed = CLIMB_SPEED;
    if (player.nearbyVines.length >= 2) climbSpeed = CLIMB_SPEED_FAST;

    if (isUp()) {
      player.y -= climbSpeed;
      if (frameCount % 8 === 0) playSound('climb');
    }
    if (isDown()) {
      player.y += CLIMB_SPEED_DOWN;
      if (frameCount % 8 === 0) playSound('climb');
    }

    // Stay on vine
    if (player.climbVine >= 0 && player.climbVine < levelData.vines.length) {
      const v = levelData.vines[player.climbVine];
      player.x = v.x - player.w / 2;

      // Reached top of vine
      if (player.y + player.h <= v.y1 + 2) {
        player.y = v.y1 - player.h;
        player.climbing = false;
        player.climbVine = -1;
        player.onGround = true;
      }
      // Reached bottom of vine
      if (player.y + player.h >= v.y2) {
        player.y = v.y2 - player.h;
        player.climbing = false;
        player.climbVine = -1;
      }
    }

    // Jump off vine
    if (isJump() && !player.jumpPressed) {
      player.climbing = false;
      player.climbVine = -1;
      player.vy = JUMP_FORCE * 0.7;
      if (isLeft()) player.vx = -PLAYER_SPEED;
      else if (isRight()) player.vx = PLAYER_SPEED;
      player.jumpPressed = true;
      playSound('jump');
    }

    // Left/right to switch vines or dismount
    if (isLeft() && !player.climbing) { player.vx = -PLAYER_SPEED; }
    if (isRight() && !player.climbing) { player.vx = PLAYER_SPEED; }

  } else {
    // WALKING / FALLING LOGIC
    player.vx = 0;
    if (isLeft()) { player.vx = -PLAYER_SPEED; player.facing = -1; }
    if (isRight()) { player.vx = PLAYER_SPEED; player.facing = 1; }

    // Jump
    if (isJump() && player.onGround && !player.jumpPressed) {
      player.vy = JUMP_FORCE;
      player.onGround = false;
      player.jumpPressed = true;
      playSound('jump');
    }

    // Grab vine
    if ((isUp() || isDown()) && player.nearbyVines.length > 0 && !player.onGround) {
      player.climbing = true;
      player.climbVine = player.nearbyVines[0];
      player.vy = 0;
      player.vx = 0;
    }
    // Also grab vine while on ground if pressing up
    if (isUp() && player.nearbyVines.length > 0 && player.onGround) {
      player.climbing = true;
      player.climbVine = player.nearbyVines[0];
      player.vy = 0;
      player.vx = 0;
      player.onGround = false;
    }

    // Apply gravity
    if (!player.onGround) {
      player.vy += GRAVITY;
      if (player.vy > 8) player.vy = 8;
    }

    // Move
    player.x += player.vx;
    player.y += player.vy;

    // Platform collision
    const plat = isOnPlatform(player);
    if (plat) {
      player.y = plat.y - player.h;
      player.vy = 0;
      player.onGround = true;
    } else if (!player.climbing) {
      player.onGround = false;
    }

    // Screen bounds
    if (player.x < 0) player.x = 0;
    if (player.x + player.w > W) player.x = W - player.w;

    // Fall off screen
    if (player.y > H + 20) {
      playerDie();
      return;
    }
  }

  // Release jump
  if (!isJump()) player.jumpPressed = false;

  // ---- ENEMIES ----
  enemySpawnTimer++;
  const spawnInterval = Math.max(120, 300 - level * 30);
  if (enemySpawnTimer >= spawnInterval && enemies.length < levelData.enemySpawns.length + 2) {
    // Spawn enemy on a vine
    const spawn = levelData.enemySpawns[Math.floor(Math.random() * levelData.enemySpawns.length)];
    if (spawn && spawn.vineIdx < levelData.vines.length) {
      const v = levelData.vines[spawn.vineIdx];
      enemies.push({
        x: v.x - 8,
        y: spawn.dir === -1 ? v.y2 : v.y1,
        w: 16, h: 16,
        vineIdx: spawn.vineIdx,
        dir: spawn.dir,
        type: spawn.type,
        speed: ENEMY_SPEED + (level - 1) * 0.15,
        animFrame: 0,
      });
      enemySpawnTimer = 0;
    }
  }

  // Update enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    const v = levelData.vines[e.vineIdx];
    if (!v) { enemies.splice(i, 1); continue; }

    e.y += e.dir * e.speed;
    e.x = v.x - 8;
    e.animFrame = (e.animFrame + 0.1) % 2;

    // Remove if off vine
    if (e.y < v.y1 - 20 || e.y > v.y2 + 20) {
      enemies.splice(i, 1);
      continue;
    }

    // Check collision with player
    if (player.invincible <= 0 && rectOverlap(player, e)) {
      // If player is above and falling, kill enemy
      if (player.vy > 0 && player.y + player.h - 8 < e.y + e.h / 2) {
        enemies.splice(i, 1);
        addScorePopup(e.x, e.y, 200);
        player.vy = JUMP_FORCE * 0.6;
        playSound('fruit');
      } else {
        playerDie();
        return;
      }
    }
  }

  // ---- FRUITS ----
  for (const f of levelData.fruits) {
    if (f.collected) continue;
    if (rectOverlap(player, { x: f.x - 8, y: f.y - 8, w: 16, h: 16 })) {
      f.collected = true;
      addScorePopup(f.x, f.y, 400);
      playSound('fruit');
      // Drop fruit particles
      for (let i = 0; i < 6; i++) {
        particles.push({
          x: f.x, y: f.y,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 3,
          life: 30,
          color: ['#ff0', '#f80', '#f00'][f.type],
        });
      }
      // Fruit drops down and kills enemies below
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        if (Math.abs(e.x + 8 - f.x) < 20 && e.y > f.y && e.y - f.y < 80) {
          enemies.splice(j, 1);
          addScorePopup(e.x, e.y, 300);
        }
      }
    }
  }

  // ---- BEETLES ----
  for (let i = beetles.length - 1; i >= 0; i--) {
    const b = beetles[i];
    if (!b.alive) continue;
    const plat = levelData.platforms[b.platformIdx];
    if (!plat) continue;

    // Move horizontally
    b.x += b.dir * b.speed;
    b.animFrame = (b.animFrame + 0.15) % 2;

    // Reverse at platform edges
    if (b.x <= plat.x) { b.x = plat.x; b.dir = 1; }
    if (b.x + b.w >= plat.x + plat.w) { b.x = plat.x + plat.w - b.w; b.dir = -1; }

    // Collision with player
    if (player.invincible <= 0 && rectOverlap(player, b)) {
      if (player.flameActive) {
        // Flame kills beetle
        b.alive = false;
        addScorePopup(b.x, b.y, 300);
        playSound('fruit');
        for (let j = 0; j < 8; j++) {
          particles.push({
            x: b.x + b.w / 2, y: b.y + b.h / 2,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4 - 1,
            life: 25 + Math.random() * 15,
            color: [COLORS.flame1, COLORS.flame2, COLORS.beetle][Math.floor(Math.random() * 3)],
          });
        }
      } else if (player.vy > 0 && player.y + player.h - 8 < b.y + b.h / 2) {
        // Stomp from above
        b.alive = false;
        addScorePopup(b.x, b.y, 200);
        player.vy = JUMP_FORCE * 0.6;
        playSound('fruit');
      } else {
        playerDie();
        return;
      }
    }
  }
  // Remove dead beetles
  for (let i = beetles.length - 1; i >= 0; i--) {
    if (!beetles[i].alive) beetles.splice(i, 1);
  }

  // ---- FLAMETHROWER PICKUP ----
  const ft = levelData.flamethrower;
  if (ft && !ft.collected && !player.hasFlamethrower) {
    if (rectOverlap(player, { x: ft.x - 8, y: ft.y - 8, w: 16, h: 16 })) {
      ft.collected = true;
      player.hasFlamethrower = true;
      playSound('pickup');
      addScorePopup(ft.x, ft.y, 100);
      for (let i = 0; i < 8; i++) {
        particles.push({
          x: ft.x, y: ft.y,
          vx: (Math.random() - 0.5) * 3,
          vy: -Math.random() * 3,
          life: 25,
          color: [COLORS.flame1, COLORS.flame2, COLORS.flamethrower][Math.floor(Math.random() * 3)],
        });
      }
    }
  }

  // ---- FLAME ACTIVATION ----
  if (player.hasFlamethrower && !player.flameActive && isFire() && !player.climbing) {
    player.flameActive = true;
    player.flameTimer = 30;
    player.hasFlamethrower = false;
    playSound('flame');
  }
  if (player.flameActive) {
    player.flameTimer--;
    // Flame hitbox - check beetles
    const flameX = player.facing === 1 ? player.x + player.w : player.x - 40;
    const flameRect = { x: flameX, y: player.y - 4, w: 40, h: player.h + 8 };
    for (let i = beetles.length - 1; i >= 0; i--) {
      const b = beetles[i];
      if (!b.alive) continue;
      if (rectOverlap(flameRect, b)) {
        b.alive = false;
        addScorePopup(b.x, b.y, 300);
        playSound('fruit');
        for (let j = 0; j < 8; j++) {
          particles.push({
            x: b.x + b.w / 2, y: b.y + b.h / 2,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4 - 1,
            life: 25 + Math.random() * 15,
            color: [COLORS.flame1, COLORS.flame2, '#fff'][Math.floor(Math.random() * 3)],
          });
        }
      }
    }
    // Flame particles
    if (frameCount % 2 === 0) {
      const fx = player.facing === 1 ? player.x + player.w + Math.random() * 30 : player.x - Math.random() * 30;
      particles.push({
        x: fx, y: player.y + 4 + Math.random() * 10,
        vx: player.facing * (1 + Math.random() * 2),
        vy: (Math.random() - 0.5) * 2,
        life: 10 + Math.random() * 8,
        color: [COLORS.flame1, COLORS.flame2, COLORS.flame3][Math.floor(Math.random() * 3)],
      });
    }
    if (player.flameTimer <= 0) player.flameActive = false;
    // Remove dead beetles
    for (let i = beetles.length - 1; i >= 0; i--) {
      if (!beetles[i].alive) beetles.splice(i, 1);
    }
  }

  // ---- KEYS ----
  for (let ki = 0; ki < levelData.keyPositions.length; ki++) {
    const k = levelData.keyPositions[ki];
    if (k.atLock) continue;

    if (k.rising) {
      k.y -= KEY_RISE_SPEED;
      const lock = levelData.lockPositions[ki];
      if (lock && k.y <= lock.y) {
        k.y = lock.y;
        k.atLock = true;
        k.locked = false;
        playSound('key');
        addScorePopup(k.x, k.y, 500);

        // Check if all keys are in locks
        if (levelData.keyPositions.every(kk => kk.atLock)) {
          gameState = 'winning';
          winTimer = 120;
          stopMusic();
          playSound('win');
          // Victory particles
          for (let i = 0; i < 30; i++) {
            particles.push({
              x: W / 2 + (Math.random() - 0.5) * 200,
              y: 60,
              vx: (Math.random() - 0.5) * 4,
              vy: Math.random() * 3 + 1,
              life: 80 + Math.random() * 40,
              color: ['#ff0', '#f00', '#0f0', '#0ff', '#f0f'][Math.floor(Math.random() * 5)],
            });
          }
        }
      }
    } else if (k.locked) {
      // Check if player is pushing key up
      if (player.climbing && k.vineIdx < levelData.vines.length) {
        const v = levelData.vines[k.vineIdx];
        if (player.climbVine === k.vineIdx ||
            (player.nearbyVines.includes(k.vineIdx))) {
          if (player.y < k.y + 10 && player.y > k.y - 20 && isUp()) {
            k.rising = true;
            playSound('key');
          }
        }
      }
    }
  }

  // Update particles
  updateParticles();

  // Update score popups
  for (let i = scorePopups.length - 1; i >= 0; i--) {
    scorePopups[i].y -= 1;
    scorePopups[i].life--;
    if (scorePopups[i].life <= 0) scorePopups.splice(i, 1);
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// ---- DRAWING ----
function draw() {
  ctx.fillStyle = COLORS.bg;
  ctx.fillRect(0, 0, W, H);

  // Draw platforms
  for (const p of levelData.platforms) {
    // Platform body
    ctx.fillStyle = COLORS.platform;
    ctx.fillRect(p.x, p.y, p.w, p.h);
    // Top highlight
    ctx.fillStyle = COLORS.platformTop;
    ctx.fillRect(p.x, p.y, p.w, 3);
    // Brick pattern
    ctx.fillStyle = '#a03008';
    for (let bx = p.x; bx < p.x + p.w; bx += 16) {
      ctx.fillRect(bx + 7, p.y + 3, 2, p.h - 3);
    }
  }

  // Draw vines
  for (const v of levelData.vines) {
    if (v.isChain) {
      // Chain style
      ctx.strokeStyle = COLORS.vineChain;
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let y = v.y1; y < v.y2; y += 8) {
        const ox = (Math.floor(y / 8) % 2) * 3 - 1.5;
        ctx.moveTo(v.x + ox, y);
        ctx.lineTo(v.x - ox, y + 8);
      }
      ctx.stroke();
    } else {
      // Vine style
      ctx.strokeStyle = COLORS.vine;
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(v.x, v.y1);
      ctx.lineTo(v.x, v.y2);
      ctx.stroke();
      // Leaves
      ctx.fillStyle = '#0d0';
      for (let y = v.y1 + 15; y < v.y2 - 10; y += 25) {
        const side = (Math.floor(y / 25) % 2) * 2 - 1;
        ctx.beginPath();
        ctx.ellipse(v.x + side * 6, y, 5, 3, side * 0.3, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Draw fruits
  for (const f of levelData.fruits) {
    if (f.collected) continue;
    const colors = ['#ff0', '#f80', '#f44'];
    ctx.fillStyle = colors[f.type];
    ctx.beginPath();
    ctx.arc(f.x, f.y, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#070';
    ctx.fillRect(f.x - 1, f.y - 9, 2, 4);
  }

  // Draw flamethrower pickup
  drawFlamethrowerPickup();

  // Draw DK and cage at top
  drawDKCage();

  // Draw locks
  for (let i = 0; i < levelData.lockPositions.length; i++) {
    const lock = levelData.lockPositions[i];
    const key = levelData.keyPositions[i];
    // Lock body
    ctx.fillStyle = key.atLock ? '#0f0' : COLORS.lock;
    ctx.fillRect(lock.x - 8, lock.y - 4, 16, 12);
    ctx.fillStyle = key.atLock ? '#080' : '#666';
    ctx.beginPath();
    ctx.arc(lock.x, lock.y - 4, 8, Math.PI, 0);
    ctx.fill();
    // Keyhole
    if (!key.atLock) {
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(lock.x, lock.y + 2, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Draw keys
  for (const k of levelData.keyPositions) {
    if (k.atLock) continue;
    ctx.fillStyle = COLORS.key;
    // Key head
    ctx.beginPath();
    ctx.arc(k.x, k.y, 5, 0, Math.PI * 2);
    ctx.fill();
    // Key shaft
    ctx.fillRect(k.x - 1.5, k.y + 5, 3, 10);
    // Key teeth
    ctx.fillRect(k.x + 1.5, k.y + 10, 4, 2);
    ctx.fillRect(k.x + 1.5, k.y + 14, 4, 2);
  }

  // Draw enemies
  for (const e of enemies) {
    drawSnapjaw(e);
  }

  // Draw beetles
  for (const b of beetles) {
    if (b.alive) drawBeetle(b);
  }

  // Draw player (if alive)
  if (gameState !== 'dying' || deathTimer > 60) {
    drawPlayer();
  }

  // Draw flame effect
  drawFlameEffect();

  // Draw particles
  for (const p of particles) {
    ctx.globalAlpha = p.life / 60;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
  }
  ctx.globalAlpha = 1;

  // Draw score popups
  ctx.font = '12px "Courier New"';
  for (const sp of scorePopups) {
    ctx.globalAlpha = sp.life / 60;
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.fillText(sp.pts.toString(), sp.x, sp.y);
  }
  ctx.globalAlpha = 1;

  // HUD
  drawHUD();

  // Level complete text
  if (gameState === 'levelComplete') {
    ctx.font = 'bold 24px "Courier New"';
    ctx.fillStyle = '#ff0';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level} COMPLETE!`, W / 2, H / 2 - 20);
    ctx.font = '16px "Courier New"';
    ctx.fillStyle = '#fff';
    ctx.fillText(`Bonus: ${1000 + level * 500}`, W / 2, H / 2 + 10);
  }

  // Winning text
  if (gameState === 'winning') {
    ctx.font = 'bold 20px "Courier New"';
    ctx.fillStyle = '#0f0';
    ctx.textAlign = 'center';
    ctx.fillText('PAPA IS FREE!', W / 2, H / 2);
  }
}

function drawDKCage() {
  const cx = W / 2;
  const cy = 35;
  const allFreed = levelData.keyPositions.every(k => k.atLock);

  // Cage
  if (!allFreed) {
    ctx.strokeStyle = COLORS.cage;
    ctx.lineWidth = 2;
    ctx.strokeRect(cx - 30, cy - 20, 60, 40);
    // Bars
    for (let bx = cx - 24; bx <= cx + 24; bx += 8) {
      ctx.beginPath();
      ctx.moveTo(bx, cy - 20);
      ctx.lineTo(bx, cy + 20);
      ctx.stroke();
    }
  }

  // DK
  ctx.fillStyle = COLORS.dk;
  // Body
  ctx.fillRect(cx - 10, cy - 10, 20, 18);
  // Head
  ctx.fillRect(cx - 8, cy - 18, 16, 10);
  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(cx - 5, cy - 15, 4, 4);
  ctx.fillRect(cx + 1, cy - 15, 4, 4);
  ctx.fillStyle = '#000';
  ctx.fillRect(cx - 4, cy - 14, 2, 2);
  ctx.fillRect(cx + 2, cy - 14, 2, 2);
  // Mouth
  ctx.fillStyle = '#a00';
  ctx.fillRect(cx - 4, cy - 10, 8, 3);

  if (allFreed) {
    // Happy DK - arms up
    ctx.fillStyle = COLORS.dk;
    ctx.fillRect(cx - 18, cy - 16, 6, 10);
    ctx.fillRect(cx + 12, cy - 16, 6, 10);
  } else {
    // Sad DK - arms at sides
    ctx.fillStyle = COLORS.dk;
    ctx.fillRect(cx - 14, cy - 4, 4, 12);
    ctx.fillRect(cx + 10, cy - 4, 4, 12);
  }
}

function drawPlayer() {
  const px = player.x;
  const py = player.y;
  const flash = player.invincible > 0 && Math.floor(frameCount / 3) % 2;
  if (flash) return;

  ctx.save();
  if (player.facing === -1 && !player.climbing) {
    ctx.translate(px + player.w, 0);
    ctx.scale(-1, 1);
    ctx.translate(0, 0);
  } else {
    ctx.translate(px, 0);
  }

  if (player.climbing) {
    // Climbing pose
    const sway = Math.sin(frameCount * 0.15) * 2;
    // Body
    ctx.fillStyle = COLORS.playerShirt;
    ctx.fillRect(2, py + 4, 12, 10);
    // Head
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(3, py, 10, 8);
    // Eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(5, py + 2, 3, 3);
    ctx.fillRect(9, py + 2, 3, 3);
    ctx.fillStyle = '#000';
    ctx.fillRect(6, py + 3, 2, 2);
    ctx.fillRect(10, py + 3, 2, 2);
    // Arms (reaching up alternating)
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(0 + sway, py + 2, 4, 3);
    ctx.fillRect(12 - sway, py + 5, 4, 3);
    // Legs
    ctx.fillRect(3, py + 14, 4, 6);
    ctx.fillRect(9, py + 14, 4, 6);
  } else {
    // Walking/standing pose
    const walk = player.vx !== 0 ? Math.sin(frameCount * 0.3) * 3 : 0;
    // Body
    ctx.fillStyle = COLORS.playerShirt;
    ctx.fillRect(2, py + 6, 12, 8);
    // Head
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(3, py, 10, 9);
    // Eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(7, py + 2, 3, 3);
    ctx.fillStyle = '#000';
    ctx.fillRect(8, py + 3, 2, 2);
    // Nose
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(11, py + 4, 3, 2);
    // Arms
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(-1, py + 7 + walk, 3, 5);
    ctx.fillRect(14, py + 7 - walk, 3, 5);
    // Legs
    ctx.fillStyle = '#22a';
    ctx.fillRect(3, py + 14 + walk, 5, 6);
    ctx.fillRect(8, py + 14 - walk, 5, 6);

    // Jump pose modification
    if (!player.onGround && !player.climbing) {
      ctx.fillStyle = COLORS.player;
      ctx.fillRect(-1, py + 3, 3, 5);
      ctx.fillRect(14, py + 3, 3, 5);
    }
  }

  ctx.restore();
}

function drawSnapjaw(e) {
  const px = e.x;
  const py = e.y;
  const frame = Math.floor(e.animFrame);
  const color = e.type === 'red' ? COLORS.snapjawRed : COLORS.snapjawBlue;

  // Body
  ctx.fillStyle = color;
  ctx.fillRect(px + 2, py + 3, 12, 10);

  // Jaw (opens and closes)
  ctx.fillRect(px + 1, py + (frame === 0 ? 1 : 0), 14, 5);
  ctx.fillRect(px + 1, py + 11 + (frame === 0 ? 1 : 2), 14, 4);

  // Teeth
  ctx.fillStyle = '#fff';
  if (frame === 1) {
    ctx.fillRect(px + 3, py + 5, 2, 2);
    ctx.fillRect(px + 7, py + 5, 2, 2);
    ctx.fillRect(px + 11, py + 5, 2, 2);
    ctx.fillRect(px + 3, py + 11, 2, 2);
    ctx.fillRect(px + 7, py + 11, 2, 2);
    ctx.fillRect(px + 11, py + 11, 2, 2);
  }

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(px + 4, py + 1, 3, 3);
  ctx.fillRect(px + 9, py + 1, 3, 3);
  ctx.fillStyle = '#000';
  ctx.fillRect(px + 5, py + 2, 2, 2);
  ctx.fillRect(px + 10, py + 2, 2, 2);
}

function drawBeetle(b) {
  const px = b.x;
  const py = b.y;
  const legAnim = Math.sin(frameCount * 0.3) * 2;

  ctx.save();
  // Flip beetle to face movement direction
  if (b.dir === -1) {
    ctx.translate(px + b.w, 0);
    ctx.scale(-1, 1);
    ctx.translate(0, 0);
  } else {
    ctx.translate(px, 0);
  }

  // Shell (rounded body)
  ctx.fillStyle = COLORS.beetleShell;
  ctx.fillRect(2, py + 2, 12, 8);
  // Shell highlight
  ctx.fillStyle = COLORS.beetle;
  ctx.fillRect(3, py + 3, 10, 3);
  // Shell stripe
  ctx.fillRect(7, py + 2, 2, 8);

  // Head
  ctx.fillStyle = COLORS.beetle;
  ctx.fillRect(12, py + 3, 4, 6);

  // Antennae
  ctx.strokeStyle = COLORS.beetleShell;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(14, py + 3);
  ctx.lineTo(16, py);
  ctx.moveTo(14, py + 5);
  ctx.lineTo(17, py + 2);
  ctx.stroke();

  // Eyes
  ctx.fillStyle = '#fff';
  ctx.fillRect(13, py + 4, 2, 2);
  ctx.fillStyle = '#000';
  ctx.fillRect(14, py + 4, 1, 1);

  // Legs (3 pairs, animated)
  ctx.fillStyle = COLORS.beetle;
  ctx.fillRect(3, py + 10 + legAnim, 2, 4);
  ctx.fillRect(7, py + 10 - legAnim, 2, 4);
  ctx.fillRect(11, py + 10 + legAnim, 2, 4);

  ctx.restore();
}

function drawFlameEffect() {
  if (!player.flameActive) return;
  const progress = player.flameTimer / 30;
  const len = 35 * progress;

  for (let i = 0; i < 5; i++) {
    const t = (frameCount * 0.3 + i * 1.2) % (Math.PI * 2);
    const spread = Math.sin(t) * 6;
    const fx = player.facing === 1
      ? player.x + player.w + i * (len / 5)
      : player.x - i * (len / 5) - 6;
    const fy = player.y + 6 + spread;
    const size = 8 - i;

    ctx.globalAlpha = 0.6 + Math.random() * 0.4;
    ctx.fillStyle = [COLORS.flame3, COLORS.flame1, COLORS.flame2, COLORS.flame1, COLORS.flame2][i];
    ctx.fillRect(fx, fy, size, size);
  }
  ctx.globalAlpha = 1;
}

function drawFlamethrowerPickup() {
  const ft = levelData.flamethrower;
  if (!ft || ft.collected) return;

  const bob = Math.sin(frameCount * 0.08) * 2;
  const px = ft.x;
  const py = ft.y + bob;

  // Tank body
  ctx.fillStyle = COLORS.flamethrower;
  ctx.fillRect(px - 5, py - 6, 10, 12);
  // Tank highlight
  ctx.fillStyle = '#fa0';
  ctx.fillRect(px - 3, py - 4, 6, 3);
  // Nozzle
  ctx.fillStyle = '#888';
  ctx.fillRect(px + 5, py - 3, 4, 3);
  // Flame tip
  ctx.fillStyle = COLORS.flame2;
  const flicker = Math.sin(frameCount * 0.4) > 0 ? 1 : 0;
  ctx.fillRect(px + 9, py - 4 - flicker, 3, 3 + flicker);
}

function drawHUD() {
  ctx.font = '14px "Courier New"';
  ctx.textAlign = 'left';

  // Score
  ctx.fillStyle = '#888';
  ctx.fillText('SCORE', 10, 16);
  ctx.fillStyle = COLORS.scoreText;
  ctx.fillText(score.toString().padStart(6, '0'), 10, 30);

  // High score
  ctx.fillStyle = '#888';
  ctx.textAlign = 'center';
  ctx.fillText('HIGH', W / 2, 16);
  ctx.fillStyle = COLORS.scoreText;
  ctx.fillText(highScore.toString().padStart(6, '0'), W / 2, 30);

  // Level
  ctx.textAlign = 'right';
  ctx.fillStyle = '#888';
  ctx.fillText('LEVEL', W - 10, 16);
  ctx.fillStyle = '#ff0';
  ctx.fillText(level.toString(), W - 10, 30);

  // Timer
  const totalSecs = Math.ceil(roundTimer / 60);
  const mins = Math.floor(totalSecs / 60);
  const secs = totalSecs % 60;
  const timeStr = mins + ':' + secs.toString().padStart(2, '0');
  ctx.textAlign = 'center';
  ctx.fillStyle = '#888';
  ctx.fillText('TIME', W / 2, H - 16);
  ctx.fillStyle = totalSecs <= 30 ? (Math.floor(frameCount / 15) % 2 ? '#f00' : '#ff0') : '#fff';
  ctx.fillText(timeStr, W / 2, H - 4);

  // Lives
  ctx.textAlign = 'left';
  for (let i = 0; i < lives; i++) {
    ctx.fillStyle = COLORS.player;
    ctx.fillRect(10 + i * 18, H - 16, 10, 10);
    ctx.fillStyle = COLORS.playerShirt;
    ctx.fillRect(12 + i * 18, H - 12, 6, 6);
  }

  // Flamethrower indicator
  if (player.hasFlamethrower || player.flameActive) {
    ctx.textAlign = 'right';
    ctx.font = '11px "Courier New"';
    ctx.fillStyle = player.flameActive
      ? (frameCount % 4 < 2 ? COLORS.flame1 : COLORS.flame2)
      : COLORS.flamethrower;
    ctx.fillText(player.flameActive ? 'FIRE!' : '[Z/X] FIRE', W - 10, H - 4);
  }

  // Dying state
  if (gameState === 'dying') {
    ctx.font = 'bold 20px "Courier New"';
    ctx.fillStyle = '#f00';
    ctx.textAlign = 'center';
    if (lives <= 0) {
      ctx.fillText('GAME OVER', W / 2, H / 2);
    } else {
      ctx.fillText('OUCH!', W / 2, H / 2);
    }
  }
}

// ---- GAME LOOP ----
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ---- START ----
initLevel();
showOverlay();
gameLoop();
</script>
</body>
</html>
